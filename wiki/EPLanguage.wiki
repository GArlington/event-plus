===Program Structure===

  * *@EPContext*

  * *Required* YES

Top level element in Event Plus is an interface. It defines one technical / business module. Not necessarily has to be the complete business solution. Remember multiple Context can interact with each other for parallel development to build the entire solution. Context provides a name space to the module. In analogy to hardware think it like a pci card hosting interconnected chips. All the java classes annotated with @EPContext goes through special code generation phase during compilation. 



{{{

@EPContext()
public interface StockQuoteAnalyzer {
}

}}}


Below is one advanced component taking advantage of processing already done in component above. See the {{{schemas}}} attribute depicitng its dependency on {{{StockQuoteAnalyzer}}} context.
{{{

@EPContext(schemas={"StockQuoteAnalyzer"})
public interface AdvancedQuoteAnalyzer {
}

}}}

  * *@EPContainer*

  * *Required* YES

In above hardware analogy one container is a chip on a pci card. Does specific processing as programmed to do so. In the example below {{{InputStocks}}} is a container which takes input from a hand coded java program {{{generator.Portfolio}}}. The container below can also be written as {{{class InputStocks}}} to get hold of more features(will be discussed later).

{{{
@EPContext()
public interface StockQuoteAnalyzer {
        ................
        ................
        ................

        @EPContainer(generator = "generator.Portfolio")
        interface InputStocks {
                String symbol = null;
                Double quantity = null;
                Double tranPrice = null;
        }
        ................
        ................
        ................

}}}

  * *@EPAttribute*
  * *Required* NO Default: @EPAttribute(type=EPAttrType.Member)

In the analogy to hardware one attribute processes one bit of information entering into the chip through its data bus. Attribute defines the behavior of the the host Container. Unless specified all members in the Containers annotated with @EPContainer are treated as the default Member attribute.

{{{
@EPContext()
public interface StockQuoteAnalyzer {
        ................
        ................
        ................

        @EPContainer(generator = "generator.Portfolio")
        interface InputStocks {
		@EPAttribute(type=EPAttrType.Member)
                String symbol = null;
		@EPAttribute(type=EPAttrType.Member)
                Double quantity = null;
		@EPAttribute(type=EPAttrType.Member)
                Double tranPrice = null;
        }
        ................
        ................
        ................

}}}


=== Behaviour ===

  * *Container Relationships* 
   # Inheritance
   # Union
   # Join
   # Subscription

  * *Container Entry* 
  
  * *Attribute dependencies*

  * *Access Privileges*
   # *Static* Just as {{{static}}} keyword in Java Language Static Attributes live in the container memory space not in each Entry. They can drive changes to all entries in the host container in case of dependencies. These attributes in short save memory other wise we would have end up spending some memory for each entry in the container.
   # *Private* Just as {{{private}}} keyword in Java Language Private Attributes are only visible in the same container and they do not propagate the information updates to listening containers. 
   # *Member* All attributes unless otherwise specified are treated as member attribute in the container. These attributes flow to down stream containers unless declared with private java keyword.
   # *Subscription* These are special purpose attributes where some external world information need to be injected into the system based on certain conditions. Such as Stock market prices, Volatility curves. These attributes are always dependent on other attribute but can NOT depend on Static Attribute. These attributes flow to down stream containers unless declared with private java keyword.
   # *Stateless* Stateless attributes live in the space of container entries how ever do not consume any memory. Every time a down stream container requests connection these attributes are recomputed.  Remember to not putting any business logic where you do not wish to perform same activity multiple times like sending an email. *If the container is the terminal container and no one listens to this container these attributes will have no effect.* These attributes flow to down stream containers unless declared with private java keyword.

  * *Transport*
   #Serialization

===Container Types===
===Attribute Types===