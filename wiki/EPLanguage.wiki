===Structure===

  * *@EPContext* *Required:* YES

Top level element in Event Plus is an interface. It defines one technical / business module. Not necessarily has to be the complete business solution. Remember multiple Context can interact with each other for parallel development to build the entire solution. Context provides a name space to the module. In analogy to hardware think it like a pci card hosting interconnected chips. All the java classes annotated with @EPContext goes through special code generation phase during compilation. 



{{{

@EPContext()
public interface StockQuoteAnalyzer {
}

}}}


Below is one advanced component taking advantage of processing already done in component above. See the {{{schemas}}} attribute depicitng its dependency on {{{StockQuoteAnalyzer}}} context.
{{{

@EPContext(schemas={"StockQuoteAnalyzer"})
public interface AdvancedQuoteAnalyzer {
}

}}}

  * *@EPContainer* *Required:* YES

In above hardware analogy one container is a chip on a pci card. Does specific processing as programmed to do so. In the example below {{{InputStocks}}} is a container which takes input from a hand coded java program {{{generator.Portfolio}}}. The container below can also be written as {{{class InputStocks}}} to get hold of more features(will be discussed later).

{{{
@EPContext()
public interface StockQuoteAnalyzer {
        ................
        ................
        ................

        @EPContainer(generator = "generator.Portfolio")
        interface InputStocks {
                String symbol = null;
                Double quantity = null;
                Double tranPrice = null;
        }
        ................
        ................
        ................

}}}

  * *@EPAttribute* *Required:* NO Default: @EPAttribute(type=EPAttrType.Member)

In the analogy to hardware one attribute processes one bit of information entering into the chip through its data bus. Attribute defines the behavior of the the host Container. Unless specified all members in the Containers annotated with @EPContainer are treated as the default Member attribute.

{{{
@EPContext()
public interface StockQuoteAnalyzer {
        ................
        ................
        ................

        @EPContainer(generator = "generator.Portfolio")
        interface InputStocks {
		@EPAttribute(type=EPAttrType.Member)
                String symbol = null;
		@EPAttribute(type=EPAttrType.Member)
                Double quantity = null;
		@EPAttribute(type=EPAttrType.Member)
                Double tranPrice = null;
        }
        ................
        ................
        ................

}}}


=== Container ===

  * *Relationships* 
   # *Inheritance* One container inherits all attributes and its entries as specified by extends and/or implements. You can extend your regular helper classes as well whenever permitted.
{{{
	@EPContext
	public interface WCalculator {
		public static class Helper {
			public static Double multiply(Double x, Double y) {
				return x * y;
			}
		}
		@EPContainer(generator="generator.HelperWorld")
		public class Calculator extends Helper{
	        	public Double x=null;
	        	public Double y=null;
	        	public Double result=multiply(x,y);
		}
	}
}}}
   # *Union* Container merges all attributes and values both vertically and horizontally. Let take example below. Container AB inherits both A and B. AB has now 4 attributes {{{a1,a2,b1,b2}}} and assume A has 4 entries and B has 5 entries then AB will have 9 entries all together. Value of attributes from other containers will be defaulted in AB container. *If container A and B hosting entries with same identity then records will be merged ending with only 5 entries.* Mode of union can be configured to Substitute(default),Merge,Ignore.
{{{
	@EPContext
	public interface UnionDemo {
		@EPContainer(generator="generator.InputA")
		public interface A{
	        	public Double a1=null;
	        	public Double a2=null;
		}
		@EPContainer(generator="generator.InputB")
		public interface B{
	        	public Double b1=null;
	        	public Double b2=null;
		}
		@EPContainer
		public class AB implements A,B{
		}
	}
}}}
   # *Join* Relational Join allows to join only 2 containers on certain key. Merge mode Union is a very restrictive form of Join  and can join more than 2 containers. Its recommended to use Union in place of Join where ever possible.
   # *Subscription* This is a special form of relation ship between containers. Entries of one container create on demand subscription on other container and the server container fulfills the obligation based on the sink container request. If you look at the code snippet below here Portfolio is Sink container requesting to container NYSE through a Subscriber attribute named nysePrice.

{{{
	@EPContext
	public interface StockQuoteAnalyzer {
		@EPContainer(type = EPConType.Subscription)
		public interface NYSE {
			@EPAttribute(type = EPAttrType.SubProcessor, processor = "processor.NYSEMarketData")
			Quote marketData = null; 
		}

		@EPContainer(generator = "generator.Portfolio")
		interface InputStocks {
			String symbol = null;
			Double quantity = null;
			Double tranPrice = null;
		}

		@EPContainer(publish=EPPublish.RMI)
		public interface Portfolio extends InputStocks {
			@EPAttribute(type = EPAttrType.Subscriber, depends = "symbol", container = "NYSE")
			public Quote nysePrice = null;
        	.................
      		.................
}}}


  * *Container Entry* 
   # *Entry Identity*
   # *Resolving Identity Conflicts*

  * *Container types*
   # *Static*
   # *Basic*
   # *Feedback*
   # *Timed*
   # *Join*
   # *Pivot*
   # *Subscription*
   # *Proxy*
   # *Split*
   # *ForkJoin*


===Attribute===
  * *Attribute typs and Access Privileges*
   # *Static* Just as {{{static}}} keyword in Java Language Static Attributes live in the container memory space not in each Entry. They can drive changes to all entries in the host container in case of dependencies. These attributes in short save memory other wise we would have end up spending some memory for each entry in the container. Static attributes can depend on other static attributes but not to others.
   # *Member* All attributes unless otherwise specified are treated as member attribute in the container. These attributes flow to down stream containers unless declared with private java keyword. These attributes can depend on other member attributes and static attributes.
   # *Subscription* These are special purpose member attributes used where some external world information need to be injected into the system based on certain conditions. Such as Stock market prices. These attributes are always dependent on other member attribute but can NOT depend on Static Attribute. These attributes flow to down stream containers unless declared with private java keyword.
   # *SubProcessor* This is a member attribute only lives in source Subscription Container. This is used in conjunction with *Subscription* attribute in sink side container. These attributes can NOT be declared private. 
   # *Private* Just as {{{private}}} keyword in Java Language Private Attributes are only visible in the same container and they do not propagate the information updates to listening containers. This is helpful where you like to mark an attribute as private in an interface. If you are using class keyword to define your container you most likely will not need this.
   # *Stateless* Stateless attributes live in the space of container entries how ever do not consume any memory. Every time a down stream container requests connection these attributes are recomputed.  Remember to not putting any business logic where you do not wish to perform same activity multiple times like sending an email. *If the container is the terminal container and no one listens to this container these attributes will have no effect.* These attributes flow to down stream containers unless declared with private java keyword.


  * *Attribute dependencies*
If you look at the container below fahrenheit attribute is dependent on celsius  and is re-evaluated whenever celsius changes.
{{{
	@EPContainer()
	public interface Weather{
		public Double celsius = null;
		public Double fahrenheit= (celsius*9/5)+32;
	}
}}}
How do I introduce dependencies where exists a self dependency. Let say I want to record min/max temperature recorded. 
{{{
	@EPContainer()
	public interface Weather{
		public Double celsius = null;
		public Double fahrenheit= (celsius*9/5)+32;
                //public Double maxTemprature = maxTemprature > fahrenheit?maxTemprature :fahrenheit; //Compilation failure
	}
}}}

Remember we spoke about we can use class instead of interface. Now its the time to look into class. Also we need to use class when exists a complex calculation which can not be in lined with a single initialization expression. If you look at the method below we are taking all inputs we care about in the formal arguments. And the name of the formal argument must be same as member argument in order compiler to succeed. Else compilation will fail though you may be seeing it all good in Eclipse. Oh Yes we yet have to talk about [IDE development environment].

{{{
	@EPContainer()
	public class Weather{
		public Double celsius = null;
		public Double fahrenheit= (Celsius*9/5)+32;
                public Double maxTemprature(Double maxTemprature,Double fahrenheit){
                 if(maxTemprature==null){
                  return fahrenheit;
                 }else{
                  return maxTemprature>fahrenheit?maxTemprature:fahrenheit;
                 }
                }
                public Double minTemprature(Double minTemprature,Double fahrenheit){
                 if(minTemprature==null){
                  return fahrenheit;
                 }else{
                  return minTemprature<fahrenheit?minTemprature:fahrenheit;
                 }
                }
	}
}}}

All good till now how ever I do not want to rewrite my business logic again its all coded already. Fair enough lets rewrite the example above
with your already existing business code.

{{{
	@EPContainer()
	public class Weather{
                //Lets mark it static so we do not end up creating converter object for every entry.
                //Thread safety of any helper object if onto you.
                @EPAttribute(type=AttrType.Static)
		public Converted myConverter = new Converter();
		public Double celsius = null;
		public Double fahrenheit= myConverter.conert(celsius);
	}
}}}
*Can I depend on static attributes?* Lets take a step back Before we talk about this lets understand why do we even care about static attributes. Lets introduce a term called fairly static. Like our federal tax rates. Which do change and when changes nearly applicable to all of us. Lets look at the example below we could have simply created an interface and done with it. Although it works but not optimal and can lead to inconsistency.
{{{
	@EPContainer()
	public interface ComputeTax{
		public Integer taxRate= 10;
		public Double income= null;
		public Double tax= income*taxRate/100;

	}
}}}
By defining like below whenever taxRate is changed its applied universally to all entries.
{{{
	@EPContainer()
	public interface ComputeTax{
		@EPAttribue(type=AttrType.Static)
		public Integer taxRate= 10;
		public Double income= null;
		public Double tax= income*taxRate/100;
	}
}}}
Cant we have done this? Yes and NO. You can inherit any interfaces/classes as Java language allows without marked with @EPContainer the members and attributes will just behave as helper members and can not propel any forward dependencies. In the sample example below there is no way taxRate can be changed without rebuilding code. OK you can argue "I can code in certain way so that i can change the value of it without rebuilding. Let say changing Integer with AtomicInteger." Still NO yes you can change the value of it but it will just introduce inconsistencies.
{{{
	public interface Constant{
		public Integer taxRate= 10.0;
	}
	@EPContainer()
	public interface ComputeTax implements Constant{
		public Double income= null;
		public Double tax= income*taxRate/100;
	}
}}}
  * *Transport*
   # Serialization

===Documentation In Progress===