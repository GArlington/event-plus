/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. PredicateParser.jj */
/*@egen*//* Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */


options {
  OUTPUT_DIRECTORY = "com/biswa/ep/util/parser/predicate"; 
             
               
  KEEP_LINE_COLUMN = false;
  STATIC = false;
                                                             
                                                                             
                                                                        
  
}

PARSER_BEGIN(PredicateBuilder)
package com.biswa.ep.util.parser.predicate;

import java.io.ByteArrayInputStream;
import com.biswa.ep.entities.predicate.Predicate;
import com.biswa.ep.entities.predicate.True;
import com.biswa.ep.util.parser.predicate.impl.PredicateBuilderVisitorImpl;
/** Predicate Grammar. */
public class PredicateBuilder/*@bgen(jjtree)*/implements PredicateBuilderTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTPredicateBuilderState jjtree = new JJTPredicateBuilderState();

/*@egen*/

  /** Entry point. */
  public static void main(String args[]) {
    System.out.println("Reading from standard input...");
    try {
    while(true){
      PredicateBuilder t = new PredicateBuilder(System.in);
      ASTStart n = t.Start();
      n.dump("Preorder Tree:");      
      PredicateBuilderVisitorImpl v = new PredicateBuilderVisitorImpl();
      n.jjtAccept(v, null);
      Predicate p = v.getPredicate();
      System.out.println("Thank you.");
      }
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
    /** Entry point. */
  public static Predicate buildPredicate(String strPredicate) {
  	if(strPredicate==null || strPredicate.trim().isEmpty()){
  		return new com.biswa.ep.entities.predicate.True();
  	}
  	Predicate p = null; 
    try {
      PredicateBuilder t = new PredicateBuilder(new ByteArrayInputStream((strPredicate+";").getBytes()));
      ASTStart n = t.Start();      
      PredicateBuilderVisitorImpl v = new PredicateBuilderVisitorImpl();
      n.jjtAccept(v, null);
      p = v.getPredicate();
    } catch (Exception e) {
		throw new RuntimeException(e);
    }
    return p;
  }
}

PARSER_END(PredicateBuilder)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : /* OPERATORS */
{
  < AND: "&&" >
|
  < OR: "||" >
|  
  < EQ: "==" >
|
  < NE: "!=" >
|
  < GT: ">" >
|
  < LT: "<" >
|
  < IN: "in" >
|
  < GE: ">=" >
|
  < LE: "<=" >
|
  < FALSE: "false" >
|
  < TRUE: "true" >
|
  < DECIMAL_LITERAL: <DECIMAL_PART> | "."<DECIMAL_PART> | (<DECIMAL_PART>("."<DECIMAL_PART>)) >
|
  <	#DECIMAL_PART:<DIGIT>(<DIGIT>)*>
|
  < STRING_LITERAL: "\""(<LETTER>|<DIGIT>)(<LETTER>|<DIGIT>)*"\"" >
|
  < ATTRIBUTE: (<LETTER>|<DIGIT>)(<LETTER>|<DIGIT>)*  >
| 
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}



/** Main production. */
ASTStart Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  Predicate() ";"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A Predicate. */
void Predicate()       : {}
{		
	LOOKAHEAD(OrPredicate())
  OrPredicate()
  |
	LOOKAHEAD(AndPredicate())
  AndPredicate()
  |
  SimplePredicate()
}

/** An Or Predicate. */
void OrPredicate() : {/*@bgen(jjtree) OrPredicate */
  ASTOrPredicate jjtn000 = new ASTOrPredicate(JJTORPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrPredicate */
  try {
/*@egen*/
	
  (
     AndOrSimple() ( <OR> AndOrSimple())+
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
/** An Or Predicate. */
void AndOrSimple()       : {}
{
	
  LOOKAHEAD(AndPredicate())
    AndPredicate()|
    SimplePredicate()
  
}
/** An And Predicate. */
void AndPredicate() : {/*@bgen(jjtree) AndPredicate */
  ASTAndPredicate jjtn000 = new ASTAndPredicate(JJTANDPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AndPredicate */
  try {
/*@egen*/
	
  (
    SimplePredicate() ( <AND> SimplePredicate() )+
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A Unary Expression. */
void SimplePredicate() : {/*@bgen(jjtree) SimplePredicate */
  ASTSimplePredicate jjtn000 = new ASTSimplePredicate(JJTSIMPLEPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}	
{/*@bgen(jjtree) SimplePredicate */
  try {
/*@egen*/
  LOOKAHEAD(EmptyPredicate())
  EmptyPredicate() 
  |
  "(" Predicate() ")" 
  | 
  LOOKAHEAD(TruePredicate())
  TruePredicate()
  |
  LOOKAHEAD(FalsePredicate())
  FalsePredicate()
  |
  EndPoint()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void EndPoint():{/*@bgen(jjtree) EndPoint */
        ASTEndPoint jjtn000 = new ASTEndPoint(JJTENDPOINT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String name; 
}
{/*@bgen(jjtree) EndPoint */
  try {
/*@egen*/ 
  Attribute()
  (
	  (
	  <EQ>
	  {  
	    name="Eq";
	  } 
	  | 
	  <NE>
	  {  
	    name="Ne";
	  }  
	  | 
	  <GT>
	  {  
	    name="Gt";
	  }  
	  |
	  <LT>
	  {  
	   	name="Lt";
	  }  
	  | 
	  <GE>
	  {  
	    name="Ge";
	  }  
	  |
	  <LE>
	  {  
	    name="Le";
	  }
	  )  
	  (Operand()/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/{jjtn000.setImage(name);}|AttributeOperand()/*@bgen(jjtree)*/
                                                                {
                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                  jjtc000 = false;
                                                                }
/*@egen*/{jjtn000.setImage("A"+name);})
  |
	  ( 
	  <IN>
	  {  
	    jjtn000.setImage("In");
	  }
	  "("Operand()(","Operand())*")"
	  ) 
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** An Attribute. */
void Attribute() :
{/*@bgen(jjtree) Attribute */
  ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Attribute */
        try {
/*@egen*/
	("${"
  t=<ATTRIBUTE>
  {
    jjtn000.setImage(t.image);
  }
  "}"
 	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** An Attribute Operand. */
void AttributeOperand() :
{/*@bgen(jjtree) AttributeOperand */
  ASTAttributeOperand jjtn000 = new ASTAttributeOperand(JJTATTRIBUTEOPERAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) AttributeOperand */
        try {
/*@egen*/
	("${"
  t=<ATTRIBUTE>
  {
    jjtn000.setImage(t.image);
  }
  "}"
 	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** An Operand. */
void Operand() :{/*@bgen(jjtree) Operand */
  ASTOperand jjtn000 = new ASTOperand(JJTOPERAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Operand */
  try {
/*@egen*/
  SOperand()|DOperand()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** An Operand. */
void SOperand() :
{/*@bgen(jjtree) SOperand */
  ASTSOperand jjtn000 = new ASTSOperand(JJTSOPERAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) SOperand */
  try {
/*@egen*/
  t=<STRING_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setImage(t.image.substring(1,t.image.length()-1));
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** An Operand. */
void DOperand() :
{/*@bgen(jjtree) DOperand */
  ASTDOperand jjtn000 = new ASTDOperand(JJTDOPERAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) DOperand */
  try {
/*@egen*/
  t=<DECIMAL_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setImage(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** True Predicate. */
void TruePredicate() :
{/*@bgen(jjtree) TruePredicate */
  ASTTruePredicate jjtn000 = new ASTTruePredicate(JJTTRUEPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) TruePredicate */
  try {
/*@egen*/
  t=<TRUE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setImage("True");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** Empty Predicate. */
void EmptyPredicate() :{/*@bgen(jjtree) EmptyPredicate */
  ASTEmptyPredicate jjtn000 = new ASTEmptyPredicate(JJTEMPTYPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EmptyPredicate */
  try {
/*@egen*/
  "(" ")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setImage("True");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** False Predicate. */
void FalsePredicate() :
{/*@bgen(jjtree) FalsePredicate */
  ASTFalsePredicate jjtn000 = new ASTFalsePredicate(JJTFALSEPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) FalsePredicate */
  try {
/*@egen*/
  t=<FALSE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setImage("False");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


